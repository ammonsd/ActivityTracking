/**
 * Description: Database schema creation script - creates tables, indexes, and constraints for the Task Activity application
 *
 * Author: Dean Ammons
 * Date: October January 2026
 */

--------------------------------
-- Schema Creation and Table Setup
--
-- This script is ONLY for initial database setup or complete rebuild.
-- DO NOT run this on a database with existing data!
--
-- Spring Boot Configuration:
-- - application.properties: spring.sql.init.mode=never (SAFE - won't run)
-- - application-local.properties: inherits never (SAFE - won't run)
-- - application-aws.properties: spring.sql.init.mode=never (SAFE - won't run)
-- - application-docker.properties: spring.sql.init.mode=always (RUNS THIS FILE - fresh container only)
--
-- Order matters: roles/permissions first, then users which references them, then other tables
---------------------------------

--------------------------------
-- Create roles table (must be created BEFORE users table)
---------------------------------
CREATE TABLE IF NOT EXISTS roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description VARCHAR(255),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--------------------------------
-- Create permissions/resources table (must be created BEFORE role_permissions table)
---------------------------------
CREATE TABLE IF NOT EXISTS permissions (
    id BIGSERIAL PRIMARY KEY,
    resource VARCHAR(100) NOT NULL,  -- e.g., 'TASK_ACTIVITY', 'USER_MANAGEMENT'
    action VARCHAR(50) NOT NULL,      -- e.g., 'READ', 'CREATE', 'UPDATE', 'DELETE'
    description VARCHAR(255),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(resource, action)
);

--------------------------------
-- Create role-permission mapping table (many-to-many)
---------------------------------
CREATE TABLE IF NOT EXISTS role_permissions (
    role_id BIGINT REFERENCES roles(id) ON DELETE CASCADE,
    permission_id BIGINT REFERENCES permissions(id) ON DELETE CASCADE,
    granted_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (role_id, permission_id)
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_role_permissions_role ON role_permissions(role_id);
CREATE INDEX IF NOT EXISTS idx_role_permissions_permission ON role_permissions(permission_id);
CREATE INDEX IF NOT EXISTS idx_permissions_resource_action ON permissions(resource, action);

--------------------------------
-- Create public.users table
---------------------------------

-- DROP statements removed for safety - only use this for initial setup
-- If you need to recreate tables, drop them manually via psql or pgAdmin
-- DROP TABLE IF EXISTS public.users CASCADE;

CREATE TABLE IF NOT EXISTS public.users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    firstname  VARCHAR(50),
    lastname  VARCHAR(50) NOT NULL,
    company  VARCHAR(100),
    userpassword VARCHAR(255) NOT NULL,
    role_id BIGINT REFERENCES roles(id),
    email VARCHAR(100),
    enabled BOOLEAN NOT NULL DEFAULT true,
    forcepasswordupdate BOOLEAN NOT NULL DEFAULT true,
    expiration_date DATE NULL,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    account_locked BOOLEAN NOT NULL DEFAULT false,
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP NULL
);

-- Create unique index on username to prevent duplicate usernames
-- This ensures data integrity and provides optimal query performance
-- Note: CONCURRENTLY cannot be used in schema.sql as it runs in a transaction
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username_unique 
ON public.users (username);

--------------------------------
-- Create revoked_tokens table for JWT token revocation/blacklist
-- Security Note: This table is part of Issue #9 (Token Revocation) from security audit
-- Ensures that tokens cannot be reused after:
-- - User logout
-- - Password change
-- - Security incidents
-- - Manual token revocation by administrators
--------------------------------
CREATE TABLE IF NOT EXISTS revoked_tokens (
    id BIGSERIAL PRIMARY KEY,
    jti VARCHAR(255) NOT NULL UNIQUE,  -- JWT ID claim (unique identifier for each token)
    username VARCHAR(50) NOT NULL,     -- Username who owned the token
    token_type VARCHAR(20) NOT NULL,   -- 'access' or 'refresh'
    expiration_time TIMESTAMP NOT NULL, -- When the token expires (for cleanup)
    revoked_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, -- When token was revoked
    reason VARCHAR(50) NOT NULL        -- 'logout', 'password_change', 'security_incident', 'manual'
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_revoked_tokens_jti ON revoked_tokens(jti);
CREATE INDEX IF NOT EXISTS idx_revoked_tokens_expiration ON revoked_tokens(expiration_time);
CREATE INDEX IF NOT EXISTS idx_revoked_tokens_username ON revoked_tokens(username);

-- Add comments to table and columns
COMMENT ON TABLE revoked_tokens IS 'JWT token blacklist for logout and password change. Stores revoked tokens to prevent reuse.';
COMMENT ON COLUMN revoked_tokens.jti IS 'JWT ID claim - unique identifier for each token';
COMMENT ON COLUMN revoked_tokens.username IS 'Username who owned the revoked token';
COMMENT ON COLUMN revoked_tokens.token_type IS 'Type of token: access or refresh';
COMMENT ON COLUMN revoked_tokens.expiration_time IS 'Original expiration time of the token (for automatic cleanup)';
COMMENT ON COLUMN revoked_tokens.revoked_at IS 'Timestamp when the token was revoked';
COMMENT ON COLUMN revoked_tokens.reason IS 'Reason for revocation: logout, password_change, security_incident, manual';

-----------------------------------
-- Create public.dropdownvalues table
-----------------------------------

-- DROP statements removed for safety - only use this for initial setup
-- If you need to recreate tables, drop them manually via psql or pgAdmin
-- DROP TABLE IF EXISTS public.dropdownvalues CASCADE;

-- Create with lowercase column names
CREATE TABLE IF NOT EXISTS public.dropdownvalues (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category VARCHAR(50) NOT NULL,
    subcategory VARCHAR(50) NOT NULL,
    itemvalue VARCHAR(255) NOT NULL,
    displayorder INTEGER NOT NULL DEFAULT 0,
    isactive BOOLEAN NOT NULL DEFAULT TRUE,
    non_billable BOOLEAN NOT NULL DEFAULT FALSE,
    CONSTRAINT uk_dropdownvalues UNIQUE (category, subcategory, itemvalue)
);

--------------------------------
-- Create public.taskactivity table
---------------------------------

-- DROP statements removed for safety - only use this for initial setup
-- If you need to recreate tables, drop them manually via psql or pgAdmin
-- DROP TABLE IF EXISTS public.taskactivity CASCADE;

-- Create with lowercase column names
CREATE TABLE IF NOT EXISTS public.taskactivity (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    taskdate DATE NOT NULL,
    client VARCHAR(255) NOT NULL,
    project VARCHAR(255) NOT NULL,
    phase VARCHAR(255) NOT NULL,
    taskhours NUMERIC(4, 2) NOT NULL,
    details VARCHAR(255),
    username VARCHAR(50) NOT NULL,
    CONSTRAINT uq_taskactivity UNIQUE (taskdate, client, project, phase, details, username),
    CONSTRAINT fk_taskactivity_username 
        FOREIGN KEY (username) REFERENCES public.users(username)
        ON DELETE RESTRICT
        ON UPDATE CASCADE
);

--------------------------------
-- Create indexes on task_activity table for improved query performance
-- These indexes benefit current filtering/sorting and future reporting features
--------------------------------

-- Index on task_date (most frequently filtered/sorted column - Dashboard, Reports)
CREATE INDEX IF NOT EXISTS idx_taskactivity_task_date ON public.taskactivity(taskdate);

-- Index on username (for user-specific queries - GUEST users, user reports)
CREATE INDEX IF NOT EXISTS idx_taskactivity_username ON public.taskactivity(username);

-- Index on client (for client filtering in dropdowns and reports)
CREATE INDEX IF NOT EXISTS idx_taskactivity_client ON public.taskactivity(client);

-- Index on project (for project filtering in dropdowns and reports)
CREATE INDEX IF NOT EXISTS idx_taskactivity_project ON public.taskactivity(project);

-- Index on phase (for phase filtering in dropdowns and reports)
CREATE INDEX IF NOT EXISTS idx_taskactivity_phase ON public.taskactivity(phase);

-- Composite index for common filter combination (date + user)
-- Optimizes queries like "show me my tasks this week"
CREATE INDEX IF NOT EXISTS idx_taskactivity_date_user ON public.taskactivity(taskdate, username);

-- Composite index for common grouping (client + project)
-- Optimizes queries that group by client and project
CREATE INDEX IF NOT EXISTS idx_taskactivity_client_project ON public.taskactivity(client, project);

CREATE TABLE IF NOT EXISTS expenses (
    -- Core & Identification
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username            VARCHAR(50) NOT NULL,

    -- Client/Project Association (Like Task Activity)
    client              VARCHAR(50) NOT NULL,
    project             VARCHAR(50),  -- Optional, some expenses may not tie to specific project

    -- Expense Details
    expense_date        DATE NOT NULL,
    expense_type        VARCHAR(50) NOT NULL,  -- From EXPENSE/EXPENSE_TYPE dropdown
    description         VARCHAR(255) NOT NULL,
    amount              NUMERIC(10, 2) NOT NULL CHECK (amount > 0),
    currency            VARCHAR(3) DEFAULT 'USD',

    -- Payment & Vendor Information
    payment_method      VARCHAR(50) NOT NULL,  -- From EXPENSE/PAYMENT_METHOD dropdown
    vendor              VARCHAR(100),          -- Vendor name (freeform or from dropdown)
    reference_number    VARCHAR(50),           -- Receipt/confirmation number

    -- Receipt Management
    receipt_path        VARCHAR(500),          -- File path to uploaded receipt image
    receipt_status      VARCHAR(50),           -- From EXPENSE/RECEIPT_STATUS dropdown

    -- Status Tracking (Critical for User Visibility)
    expense_status      VARCHAR(50) NOT NULL DEFAULT 'Draft',  -- From EXPENSE/EXPENSE_STATUS

    -- Approval Details
    approved_by         VARCHAR(100),
    approval_date       DATE,
    approval_notes      VARCHAR(500),          -- Approval/rejection comments

    -- Reimbursement Tracking
    reimbursed_amount   NUMERIC(10, 2) CHECK (reimbursed_amount >= 0 AND reimbursed_amount <= amount),
    reimbursement_date  DATE,
    reimbursement_notes VARCHAR(500),

    -- Additional Notes
    notes               VARCHAR(500),          -- User's additional notes

    -- Auditing (Auto-managed timestamps)
    created_date        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_modified       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_modified_by    VARCHAR(100),

    -- Foreign Key Constraints
    CONSTRAINT fk_expense_username
        FOREIGN KEY (username)
        REFERENCES users(username)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,

    -- Business Logic Constraints
    CONSTRAINT chk_approval_logic
        CHECK (
            (approval_date IS NULL AND approved_by IS NULL) OR
            (approval_date IS NOT NULL AND approved_by IS NOT NULL)
        ),
    CONSTRAINT chk_reimbursement_logic
        CHECK (
            (reimbursement_date IS NULL) OR
            (reimbursement_date IS NOT NULL AND expense_status = 'Reimbursed')
        )
);

-- Performance Indexes
CREATE INDEX idx_expenses_username ON expenses (username);
CREATE INDEX idx_expenses_date ON expenses (expense_date);
CREATE INDEX idx_expenses_client ON expenses (client);
CREATE INDEX idx_expenses_project ON expenses (project);
CREATE INDEX idx_expenses_status ON expenses (expense_status);
CREATE INDEX idx_expenses_type ON expenses (expense_type);
CREATE INDEX idx_expenses_payment_method ON expenses (payment_method);

-- Combined indexes for common queries
CREATE INDEX idx_expenses_user_date ON expenses (username, expense_date DESC);
CREATE INDEX idx_expenses_user_status ON expenses (username, expense_status);
CREATE INDEX idx_expenses_client_project ON expenses (client, project);

--------------------------------
-- Create password_history table for password reuse prevention
-- Security Feature: Prevents users from reusing their recent passwords
-- Stores BCrypt hashed passwords only (never plain text)
-- Maintains configurable history (default: 5 most recent passwords)
--------------------------------
CREATE TABLE IF NOT EXISTS password_history (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    changed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Performance indexes for password history queries
-- idx_password_history_user_id: Fast lookup of user's password history
-- idx_password_history_changed_at: Efficient ordering and cleanup of old entries
CREATE INDEX IF NOT EXISTS idx_password_history_user_id ON password_history(user_id);
CREATE INDEX IF NOT EXISTS idx_password_history_changed_at ON password_history(changed_at);

-- Comments for documentation
COMMENT ON TABLE password_history IS 'Stores password history to prevent password reuse. Only BCrypt hashes are stored, never plain text.';
COMMENT ON COLUMN password_history.user_id IS 'Foreign key to users table. CASCADE DELETE ensures cleanup when user is deleted.';
COMMENT ON COLUMN password_history.password_hash IS 'BCrypt hash of the password (same format as users.userpassword). Used for password validation.';
COMMENT ON COLUMN password_history.changed_at IS 'Timestamp when this password was set. Used for ordering and cleanup of old entries.';